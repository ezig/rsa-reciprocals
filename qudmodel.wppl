// Helper functions for computing number of pairs
var factorial = cache(function(n) {
  product(mapIndexed(function(i, v) { i + 1 },
                     repeat(n, function() { return 0 })));
});

var nchoosek = cache(function(n, k) {
  return (factorial(n) / factorial(k) / factorial(n - k));
});
//

var contextPriors = {
  "classroom.interact" : {
    within_group_1_prob: 0.8,
    within_group_2_prob: 0.8,
    across_prob: 0.2
  },
  "classroom.dontknow" : {
    within_group_1_prob: 0.2,
    within_group_2_prob: 0.2,
    across_prob: 0.8
  },
  "classroom.hate" : {
    within_group_1_prob: 0.4,
    within_group_2_prob: 0.4,
    across_prob: 0.6
  },
  "classroom.presentto" : {
    within_group_1_prob: 0.6,
    within_group_2_prob: 0.6,
    across_prob: 0.4
  },
  "sports.raced" : {
    within_group_1_prob: 0.8,
    within_group_2_prob: 0.8,
    across_prob: 0.2
  },
  "sports.cheeredon" : {
    within_group_1_prob: 0.2,
    within_group_2_prob: 0.2,
    across_prob: 0.8
  },
  "sports.congratulated" : {
    within_group_1_prob: 0.4,
    within_group_2_prob: 0.4,
    across_prob: 0.6
  },
  "sports.warmedup" : {
    within_group_1_prob: 0.6,
    within_group_2_prob: 0.6,
    across_prob: 0.4
  },
}

// Number of individuals in each of the two groups
var group_1_size = 4;
var group_2_size = 4;

var utterances = ["null", "eachother"];

// Two possible group interpretations for "eachother"
var group_interp = ["within", "across"];

var quds = ["all", "any", "most"];

var utterancePrior = function() {
  return uniformDraw(utterances);
}

var groupInterpPrior = function() {
  return uniformDraw(group_interp);
}

var qudPrior = function() {
  return uniformDraw(quds);
}

// Given either group 1 or group 2, sample from the prior on how many
// pairs the predicate holds on within that group
var within_group_prior = function(group_num, context) {
  var cp = contextPriors[context];
  
  if (group_num == 1) {
    // Calculate how many pairs there are in the group
    var within_group_1_pairs = nchoosek(group_1_size, 2);
    // Prior distribution is <number of pairs> bernoulli trials each
    // of which has prior probability set above
    return sample(Binomial({p: cp.within_group_1_prob, n: within_group_1_pairs}));
  } else {
    var within_group_2_pairs = nchoosek(group_1_size, 2);
    return sample(Binomial({p: cp.within_group_2_prob, n: within_group_2_pairs}));
  }
}

// Sample from the prior on how many across-group pairs the predicate holds on
var across_group_prior = function(context) {
  var cp = contextPriors[context];
  
  // Number of pairs is members of group 1 * members of group 2
  var across_group_pairs = group_1_size * group_2_size;
  return sample(Binomial({p: cp.across_prob, n: across_group_pairs}));
}

// Put all of the different state priors together for convenience
var statePrior = function(context) {
  return {
    group1: within_group_prior(1, context),
    group2: within_group_prior(2, context),
    across: across_group_prior(context),
  }
}

var isAll = function(state, group_interp) {
  if (group_interp === "within") {
    var within_group_1_pairs = nchoosek(group_1_size, 2);
    var within_group_2_pairs = nchoosek(group_2_size, 2);
    
    return (state.group1 === within_group_1_pairs
            && state.group2 === within_group_2_pairs);
  } else if (group_interp === "across") {
    var across_group_pairs = group_1_size * group_2_size;
    return state.across === across_group_pairs;
  }
}

var qudFns = {
  any : function(state, group_interp) {
    if (group_interp === "within") {
      return (state.group1 > 0 && state.group2 > 0);
    } else if (group_interp === "across") {
      return (state.across > 0);
    }
  },
  most : function(state, group_interp) {
    if (group_interp === "within") {
      var within_group_1_pairs = nchoosek(group_1_size, 2);
      var within_group_2_pairs = nchoosek(group_2_size, 2);
      
      return (state.group1 >= (within_group_1_pairs / 2)
      && state.group2 >= (within_group_2_pairs / 2));
    } else if (group_interp === "across") {
      var across_group_pairs = group_1_size * group_2_size;
      return state.across >= (across_group_pairs / 2);
    }
  },
  all : isAll
}

// Literal meaning of utterance given the utterance, state, two thresholds, 
// and which interpretation to use
var meaning = function(utterance, state, group_interp) {
  if (utterance === "eachother") {
    return isAll(state, group_interp);
  } else if (utterance === "null") {
    return true;
  }
}

// Literal listener samples a state and conditions on truth value
var literalListener = cache(function(utterance, group_interp, qud, context) {
  Infer({method: "enumerate"}, function() {
    var state = statePrior(context);
    condition(meaning(utterance, state, group_interp));
    
    var qudFn = qudFns[qud]
    
    return qudFn(state, group_interp);
  });
});

// Pragmatic speaker samples an utterance and factors based on listener informativity
var alpha1 = 1;
var pragmaticSpeaker = cache(function(qudValue, group_interp, qud, context) {
  return Infer({method: 'enumerate', model: function() {
    var utterance = utterancePrior();
    factor(alpha1 * literalListener(utterance, group_interp, qud, context)
           .score(qudValue));
    return utterance;
  }});
});

// Pragmatic listener jointly infers the state, two thresholds, and which
// interpretation to use, and factors based on pragmatic speaker
var pragmaticListener = cache(function(utterance, context) {
  return Infer({method: 'enumerate', model: function() {
    /// priors ///
    var state = statePrior(context);
    var qud = qudPrior();
    var group_interp = groupInterpPrior();
    //////////////
    
    var qudFn = qudFns[qud];
    var qudValue = qudFn(state, group_interp);
    
    observe(pragmaticSpeaker(qudValue, group_interp, qud, context), utterance);
    
    return state;
  }})
});

// S2 is given a state, samples an utterance, and factors based on informativity
// to the pragmatic listener (models speaker endorsement in a truth-value judgement)
var alpha2 = 1;
var s2 = cache(function(state, context) {
  return Infer({method: 'enumerate', model: function() {
    var utterance = utterancePrior();
    factor(alpha2 * pragmaticListener(utterance, context).score(state))
    return utterance;
  }});
});

var state = {
  group1: 3,
  group2: 3,
  across: 8
}

s2(state, "sports.congratulated");